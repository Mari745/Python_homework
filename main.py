#Дано натуральное число A > 1. Определите, каким по счету числом Фибоначчи оно является, то есть выведите такое число n, что φ(n)=A. Если А не является числом Фибоначчи, выведите число -1.
# a = int(input())
# if a == 0:
#     print(0)
# else:
#     fib_prev,fib_next = 0,1
#     n = 1
#     while fib_next <= a:
#         if fib_next == a:
#             print(n)
#             break
#         fib_prev,fib_next = fib_next,fib_prev+fib_next
#         n+=1
#     else:
#         print(-1)

#найти количество уникальных чисел

#list=[1,1,2,0,-1,3,4,4]
#print(len(set(list)))


# list=[1,2,3,4,5]
# list_2 = (list[len(list)- 2:]+list[ : 3])
# print(list_2)

# dictionary=[{"V": "S001"}, {"V": "S002"}, {"VI": "S001"}, {"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII ":" S007 "}] 
# list=[]
# for a in dictionary:
#     for item in a:
#         list.append(a[item])
#     print(set(list))



# Дан массив, состоящий из целых чисел. Напишите программу, которая подсчитает количество элементов массива, больших предыдущего (элемента с предыдущим номером) 

# Input: [0, -1, 5, 2, 3]

# Output: 2 

# Пояснение: (-1 < 5, 2 < 3)

# list=[0, -1, 5, 2, 3]
# a=0
# for i in range(1,len(list)):
#     if list[i] > list[i-1]:
#         a += 1
# print(a)

# Хакер Василий получил доступ к классному журналу и хочет заменить все свои минимальные оценки на максимальные.
# Напишите программу, которая заменяет оценки Василия, но наоборот: все максимальные – на минимальные.
# Input: 5 -> 1 3 3 3 4

# Output: 1 3 3 3 1
# def SwapMark(arr):
#     max=arr[0]
#     min=arr[0]
#     for i in range (1,len(arr)):
#         if max<arr[i]:
#             max=arr[i]
#         if min>arr[i]:
#             min=arr[i] 
#     for i in range (len(arr)):
#         if arr[i]==max:
#             arr[i]=min           
#     print(arr)
# arr=[1,2,3,4,5,4,3,2,2]
# SwapMark(arr)

# Напишите функцию, которая принимает одно число и проверяет, является ли оно простым

# Напоминание: Простое число - это число, которое имеет 2 делителя: 1  и n(само число)


# Input: 5

# Output: yes
# def Chek(number):
#     for i in range(2,number):
#         if number%i==0:
#             return(f"Число{number} не простое,так как делится на {i}")
    
#         return(f"Число простое")    
# number=int(input("Ввeдите число: "))
# res=Chek(number)
# print(res)   

# Дано натуральное число N и последовательность из N элементов.
# Требуется вывести эту последовательность в обратном порядке.
# Примечание. В программе запрещается объявлять массивы и использовать циклы (даже для ввода и вывода).

# Input:    2 -> 3 4
# Output: 4 3         
# def pos(number):
    
#     if number == 0:
#         return " "
#     x=int(input("Введите число: "))
#     return pos(number-1)+str(x)
# number = int(input("Введите количество элементов: "))
# print(pos(number))

# Последовательностью Фибоначчи называется последовательность чисел a0, a1, ..., an, ..., где
# a0 = 0, a1 = 1, ak = ak-1 + ak-2 (k > 1).
# Требуется найти N-е число Фибоначчи
# Input: 7
# Output: 21

# def fib(n):
#     if n>0:
#         if n in [1,2]:
#             return 1
#         return fib(n-1)+fib(n-2)
#     else:
#         if n in [-1]:
#             return 1
#         return fib(n+1)-fib(n+2)
# list =[]
# for i in range(-10,-1):
#     list.append(fib(i))
# print(list)    

# def fib(n):
#     if n > 0:
#         if n in [1,2]:
#             return 1
#         return fib(n-1) + fib(n-2)
#     else:
#         if n in [-1]:
#             return 1
#         return fib(n+2) - fib(n+1)
# list = []
# for i in range(-10,-1):
#     list.append(fib(i))
# print(list)

# Даны два массива чисел. Требуется вывести те элементы первого массива (в том порядке, в каком они идут в первом массиве), которых нет во втором массиве. 
# Пользователь вводит  число N - количество элементов в первом массиве, затем N чисел - элементы массива.
# Затем число M - количество элементов во втором массиве. Затем элементы второго массива
# Ввод: 					Вывод:
# 7					3 3 2 12
# 3 1 3 4 2 4 12
# 6
# 4 15 43 1 15 1			(каждое число вводится с новой строки)
# list1=[3, 1, 3,4, 2, 4, 12]
# list2=[4, 15, 43, 1, 15, 1]

# for i in range (len(list1)):
    
#         if list1[i] not in list2:
#             print(list1[i])          

# Дан массив, состоящий из целых чисел. Напишите программу, которая в данном массиве определит количество элементов, у которых два соседних и, при этом, оба соседних элемента меньше данного. 
# Сначала вводится число N — количество элементов в массиве  Далее записаны N чисел — элементы массива.
# Массив состоит из целых чисел. 

# Ввод: 			Ввод:
# 5				5
# 1 2 3 4 5			1 5 1 5 1

# Вывод:			Вывод:
# 0				2
				
# (каждое число вводится с новой строки)

# import random
# list1 = []
# for i in range(1,10):
#     i = random.randint(1,10)
#     list1.append(i)
# print(list1)
# count = 0
# for i in range(1, len(list1)-1):
#     if list1[i-1] < list1[i] > list1[i+1]:
#         count += 1
# print(count)

# Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. 
# Считается, что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.
# Вводится список чисел. Все числа списка находятся на разных строках.
# Ввод:			Вывод:
# 1 2 3 2 3			2

# list=[1,2,3,2,3]
# count=0
# for i in range(len(list)-1):
#     j=i+1
#     while j<len(list):
#         if list[i]==list[j]:
#             count+=1
#         j+=1
# print(count)

# Два различных натуральных числа n и m называются дружественными, если сумма делителей числа n (включая 1, но исключая само n) равна числу m и наоборот. 
# Например, 220 и 284 – дружественные числа. По данному числу k выведите все пары дружественных чисел, каждое из которых не превосходит k. 
# Программа получает на вход одно натуральное число k, не превосходящее 105. Программа должна вывести  все пары дружественных чисел, каждое из которых не превосходит k. Пары необходимо выводить по одной в строке, разделяя пробелами. Каждая пара должна быть выведена только один раз (перестановка чисел новую пару не дает).
# Ввод:			Вывод:
# 300			220 284
        
# def sumDel(number):
#     sum = 0
#     for i in range(1, number):
#         if number % i == 0:
#             sum = sum + i
#     return sum
# number1 = 1
# number2 = 1
# numberK = int(input('Введите число: '))
# for i in range(2, numberK):
#     for j in range(i+1, numberK):
#         number1 = i
#         number2 = j
#         if sumDel(number1) == number2 and sumDel(number2) == number1:
#             print(f'{number1} и {number2}')

###Функции высшего порядка
# У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине
# программы используется множество раз и вы не хотите ничего сломать):
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# Единственный способ вашего взаимодействия с этим кодом - посредством задания
# функции transformation.
# Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать
# список значений, а нужно получить его как есть.
# Напишите такое лямбда-выражение transformation, чтобы transformed_values получился
# копией values.

# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 
# transormed_values = list(map(transformation, values))


# values = [1, 23, 42, ‘asdfg’]
# transformed_values = list(map(trasformation, values))
# if values == transformed_values:
#     print(‘ok’)
# else:
#     print(‘fail’)
          
#     Планеты вращаются вокруг звезд по эллиптическим орбитам.
#       Назовем самой далекой планетой ту, орбита которой имеет самую большую площадь. 
#       Напишите функцию find_farthest_orbit(list_of_orbits), которая среди списка орбит планет найдет ту, 
#       по которой вращается самая далекая планета. Круговые орбиты не учитывайте: 
#       вы знаете, что у вашей звезды таких планет нет, зато искусственные спутники были были запущены на 
#       круговые орбиты. Результатом функции должен быть кортеж, содержащий длины полуосей эллипса орбиты
#         самой далекой планеты. Каждая орбита представляет из себя кортеж из пары чисел - полуосей ее эллипса.
#           Площадь эллипса вычисляется по формуле S = pi*a*b, где a и b - длины полуосей эллипса.
#             При решении задачи используйте списочные выражения. Подсказка: проще всего будет найти эллипс в
#               два шага: сначала вычислить самую большую площадь эллипса, а затем найти и сам эллипс, имеющий 
#               такую  площадь. 
#     Гарантируется, что самая далекая планета ровно одна      
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# list1 = [i for i in orbits if i[0] != i[1] ]
# list2 = (list(map(lambda x: 3.14 * x[0] * x[1], list1)))
# print(list1[list2.index(max(list2))])
# Напишите функцию same_by(characteristic, objects), которая
# проверяет, все ли объекты имеют одинаковое значение
# некоторой характеристики, и возвращают True, если это так.
# Если значение характеристики для разных объектов
# отличается - то False. Для пустого набора объектов, функция
# должна возвращать True. Аргумент characteristic - это
# функция, которая принимает объект и вычисляет его
# характеристику.
# def filt(funk,arr):
#     res = list(map(funk,arr))
#     for i in range(len(res)-1):
#         if res[i] != res[i+1]:
#            return False
#     return True
# values = [0, 2, 10, 6, 14]
# list1 = filt(lambda x: x % 2, values)
# print(list1)
# Задача 34:  Винни-Пух попросил Вас посмотреть, есть ли в его стихах ритм.
# Поскольку разобраться в его кричалках не настолько просто, насколько легко он их придумывает, 
# Вам стоит написать программу. Винни-Пух считает, что ритм есть, если число слогов (т.е. число гласных букв) в каждой фразе стихотворения одинаковое. 
# Фраза может состоять из одного слова, если во фразе несколько слов, то они разделяются дефисами.
# Фразы отделяются друг от друга пробелами. Стихотворение  Винни-Пух вбивает в программу с клавиатуры.
# В ответе напишите “Парам пам-пам”, если с ритмом все в порядке и “Пам парам”, если с ритмом все не в порядке

# Ввод:                                                                                         Вывод:

# пара-ра-рам рам-пам-папам па-ра-па-дам                Парам пам-пам